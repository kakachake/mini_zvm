<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mvvm</title>
  </head>
  <body>
    <div id="app"></div>
  </body>
  <script src="./dist//iife/main.js"></script>
  <script>
    const { effect, reactive, computed, watch } = ZVM;
    // console.log(effect);
    // const data = reactive({
    //   a: 1,
    //   b: {
    //     c: 4,
    //   },
    //   is: true,
    // });
    // effect(() => {
    //   console.log(data.is ? data.a : data.b.c);
    //   effect(() => {
    //     // 会执行5次，data.is*2、data.a*3
    //     console.log("嵌套的effect", data.a);
    //   });
    // });

    // effect(
    //   () => {
    //     console.log(data.a);
    //   },
    //   {
    //     scheduler(effect) {
    //       Promise.resolve().then(() => {
    //         console.log("这是scheduler打印的，应该在最后打印：");
    //         effect();
    //       });
    //     },
    //   }
    // );
    // cData = computed(() => {
    //   return data.a + data.b.c;
    // });

    // watch(
    //   cData,
    //   (newValue) => {
    //     console.log("watch computed：", newValue.value);
    //   },
    //   {
    //     immediate: true,
    //   }
    // );
    // console.log(cData);
    // watch(
    //   () => cData.value,
    //   (newValue) => {
    //     console.log("watch computed fn：", newValue);
    //   },
    //   {
    //     immediate: true,
    //   }
    // );
    // // 虽然数据改变了四次，但是只会执行三次副作用函数
    // data.is = false; // 执行
    // data.a = 2; // 不执行，因为is===false，不会收集data.a依赖
    // data.is = true; // 执行
    // data.a = 3; // 执行
    // const a = reactive([]);

    // // effect(() => {
    // //   console.log("遍历开始");
    // //   for (i in a) {
    // //     console.log(a[i]);
    // //   }
    // //   console.log("遍历结束");
    // // });

    // effect(() => {
    //   for (i in a) {
    //     console.log(a[i]);
    //   }
    // });

    // a.push(1);
    // a.push(1);
    // a.push(1);
    // const obj2 = reactive({
    //   a: 1,
    //   b: 2,
    // });
    // const computedAPlusB = computed(() => {
    //   return obj2.a + obj2.b;
    // });
    // watch(
    //   () => computedAPlusB.value,
    //   (newVal) => {
    //     console.log(newVal);
    //   }
    // );
    // obj2.a = 2;
    // const s = new Set([1, 2, 3]);
    // const m = new Map([
    //   ["a", 1],
    //   ["b", 2],
    // ]);
    // const ps = reactive(s);
    // const pm = reactive(m);
    // effect(() => {
    //   console.log(ps.size);
    //   console.log(pm.size);
    // });
    // ps.add(4);
    // pm.delete("a");
    // const p = reactive(new Map([["key", 1]]));
    // effect(() => {
    //   console.log(p.get("key"));
    // });
    // p.set("key", 2);

    // 原始值污染
    // const m = new Map();
    // const p1 = reactive(m);
    // const p2 = reactive(new Map());
    // p1.set("p2", p2);
    // effect(() => {
    //   console.log(m.get("p2").size);
    // });
    // m.get("p2").set("foo", "bar");

    // 处理forEach
    const m = reactive(new Map([["3", new Set([1, 2, 3])]]));
    effect(() => {});
    m.set("3", 3);
    // m.get("3").add(4);
  </script>
</html>
